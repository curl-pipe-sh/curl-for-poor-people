#!/usr/bin/env sh
# curl-ossl â€” tiny curl-ish fetcher using openssl s_client (binary-safe)

set -eu

MAX_REDIRECTS_DEFAULT=5

usage() {
  echo "Usage: $0 [OPTIONS] URL"
  echo
  echo "Options:"
  echo "  -s                Silent (suppress TLS error chatter)"
  echo "  -S                Show errors (useful with -s)"
  echo "  -o FILE           Write body to FILE"
  echo "  -I                Headers only"
  echo "  -L                Follow redirects (default on)"
  echo "  --max-redirs N    Set redirect limit (default ${MAX_REDIRECTS_DEFAULT})"
  echo "  -f                Fail on HTTP >= 400 (exit 22)"
  echo "  -4                Force IPv4 (require A record; else exit 6)"
  echo "  -6                Force IPv6 (require AAAA; else exit 6)"
  echo "  -h, --help        Show this help"
}

silent=false
show_error=false
outfile=
head_only=false
fail_on_error=false
max_redirs=$MAX_REDIRECTS_DEFAULT
force_v4=false
force_v6=false
url=

# ---- args ----
while [ $# -gt 0 ]
do
  case "$1" in
    -s)
      silent=true
      shift
    ;;
    -S)
      show_error=true
      shift
    ;;
    -o)
      shift
      outfile=${1:-}
      [ -n "${outfile:-}" ] || { usage; exit 2; }
      shift
    ;;
    -I)
      head_only=true
      shift
    ;;
    -L)
      # default follows redirects; keep for compatibility
      shift
    ;;
    --max-redirs)
      shift
      max_redirs=${1:-}
      [ -n "${max_redirs:-}" ] || { usage; exit 2; }
      shift
    ;;
    -f)
      fail_on_error=true
      shift
    ;;
    -4)
      force_v4=true
      force_v6=false
      shift
    ;;
    -6)
      force_v6=true
      force_v4=false
      shift
    ;;
    -h|--help)
      usage
      exit 0
    ;;
    -*)
      usage
      exit 2
    ;;
    *)
      url=$1
      shift
      break
    ;;
  esac
done

[ -n "${url:-}" ] || { usage; exit 2; }

# default to https if no scheme
case "$url" in
  http://*|https://*) : ;;
  *) url="https://$url" ;;
esac

# ---- helpers ----

parse_url() {
  _u=$1
  case "$_u" in
    https://*) proto=https; rest=${_u#https://} ;;
    http://*)  proto=http;  rest=${_u#http://}  ;;
    *)         proto=https; rest=$_u            ;;
  esac

  case "$rest" in
    */*) hostport=${rest%%/*}; path="/${rest#*/}" ;;
    *)   hostport=$rest;        path="/"          ;;
  esac

  case "$hostport" in
    *:*) host=${hostport%:*}; port=${hostport#*:} ;;
    *)   host=$hostport; [ "$proto" = https ] && port=443 || port=80 ;;
  esac

  printf '%s %s %s %s\n' "$proto" "$host" "$port" "$path"
}

resolve_ip_v4() {
  _host=$1
  if command -v getent >/dev/null 2>&1
  then
    ip=$(getent ahostsv4 "$_host" 2>/dev/null | awk 'NF{print $1; exit}')
    [ -n "${ip:-}" ] && { printf '%s\n' "$ip"; return 0; }
    ip=$(getent hosts "$_host" 2>/dev/null | awk '$1 ~ /^([0-9]+\.){3}[0-9]+$/ {print $1; exit}')
    [ -n "${ip:-}" ] && { printf '%s\n' "$ip"; return 0; }
  fi
  if command -v nslookup >/dev/null 2>&1
  then
    ip=$(nslookup -type=A "$_host" 2>/dev/null | awk '/^Address: /{print $2; found=1} END{if(found) exit 0; else exit 1}')
    [ -n "${ip:-}" ] && { printf '%s\n' "$ip"; return 0; }
  fi
  return 1
}

resolve_ip_v6() {
  _host=$1
  if command -v getent >/dev/null 2>&1
  then
    ip6=$(getent ahostsv6 "$_host" 2>/dev/null | awk 'NF{print $1; exit}')
    [ -n "${ip6:-}" ] && { printf '%s\n' "$ip6"; return 0; }
    ip6=$(getent hosts "$_host" 2>/dev/null | awk '$1 ~ /:/ {print $1; exit}')
    [ -n "${ip6:-}" ] && { printf '%s\n' "$ip6"; return 0; }
  fi
  if command -v nslookup >/dev/null 2>&1
  then
    ip6=$(nslookup -type=AAAA "$_host" 2>/dev/null | awk '/has IPv6 address/ {print $NF; exit}')
    [ -n "${ip6:-}" ] && { printf '%s\n' "$ip6"; return 0; }
  fi
  return 1
}

bracket_if_ipv6() {
  case "$1" in
    *:*) printf '[%s]\n' "$1" ;;
    *)   printf '%s\n' "$1"   ;;
  esac
}

# stream HTTPS response: headers -> $1, body raw -> $2
# returns:
#   0  success
#   6  resolve error when -4/-6 requested
#   1  connection/TLS failure
fetch_https_stream() {
  hdrf=$1
  rawf=$2
  _host=$3
  _port=$4
  _path=$5

  # honor -4/-6 strictly
  connect_host=
  if $force_v4
  then
    if connect_host=$(resolve_ip_v4 "$_host")
    then :; else
      [ "$silent" = false ] || [ "$show_error" = true ] && echo "curl-ossl: could not resolve IPv4 for $_host" >&2 || true
      return 6
    fi
  elif $force_v6
  then
    if connect_host=$(resolve_ip_v6 "$_host")
    then :; else
      [ "$silent" = false ] || [ "$show_error" = true ] && echo "curl-ossl: could not resolve IPv6 for $_host" >&2 || true
      return 6
    fi
  else
    connect_host="$_host"
  fi

  connect_target="$(bracket_if_ipv6 "$connect_host"):${_port}"
  req="GET $_path HTTP/1.1\r\nHost: $_host\r\nUser-Agent: curl-ossl\r\nAccept: */*\r\nConnection: close\r\n\r\n"

  for args in \
    "-quiet -ign_eof -connect $connect_target -tls1_3 -servername $_host" \
    "-quiet -ign_eof -connect $connect_target -tls1_2 -servername $_host" \
    "-quiet -ign_eof -connect $connect_target -tls1_2"
  do
    errf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-err")

    printf '%b' "$req" \
    | openssl s_client $args 2>"$errf" \
    | {
        : >"$hdrf"
        while IFS= read -r line
        do
          line=$(printf '%s' "$line" | tr -d '\r')
          [ -z "$line" ] && break
          printf '%s\n' "$line" >>"$hdrf"
        done
        cat >"$rawf"
      } || true

    if head -n1 "$hdrf" | grep -q '^HTTP/'; then
      rm -f "$errf" || true
      return 0
    fi

    if [ "$silent" = false ] || [ "$show_error" = true ]
    then
      sed 's/^/openssl: /' "$errf" >&2 || true
    fi
    rm -f "$errf" || true
  done

  return 1
}

# decode chunked body (binary-safe): in=$1, out=$2
dechunk_file() {
  in=$1
  out=$2
  : >"$out"
  exec 9<"$in"

  read_crlf_line() {
    IFS= read -r -u 9 line || return 1
    line=$(printf '%s' "$line" | tr -d '\r')
    return 0
  }

  while read_crlf_line
  do
    sizehex=${line%%;*}
    [ -n "$sizehex" ] || continue
    case "$sizehex" in *[!0-9a-fA-F]* ) break ;; esac
    size=$((16#$(printf '%s' "$sizehex" | tr 'a-f' 'A-F')))
    [ "$size" -gt 0 ] || { break; }
    dd bs=1 count="$size" <&9 >>"$out" 2>/dev/null || true
    IFS= read -r -u 9 _ || true  # consume CRLF
  done

  exec 9<&-
}

follow() {
  cur=$1
  n=0

  while :; do
    n=$((n+1))
    [ "$n" -le "$max_redirs" ] || { [ "$silent" = false ] && echo "curl-ossl: too many redirects" >&2; return 22; }

    set -- $(parse_url "$cur")
    proto=$1; host=$2; port=$3; path=$4

    if [ "$proto" != https ]
    then
      [ "$silent" = false ] && echo "curl-ossl: only https supported (got $proto)" >&2
      return 2
    fi

    hdrf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-hdr")
    rawf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-raw")

    if ! fetch_https_stream "$hdrf" "$rawf" "$host" "$port" "$path"
    then
      rc=$?
      rm -f "$hdrf" "$rawf"
      case "$rc" in
        6)  return 6 ;;   # could not resolve host (forced family)
        *)  [ "$silent" = false ] && echo "curl-ossl: connection failed" >&2; return 1 ;;
      esac
    fi

    status=$(head -n1 "$hdrf" 2>/dev/null | awk '{print $2+0}')
    [ -z "$status" ] && status=0

    if [ "$head_only" = true ]
    then
      cat "$hdrf"
      rm -f "$hdrf" "$rawf"
      return "$status"
    fi

    if [ "$status" -ge 300 ] && [ "$status" -lt 400 ]
    then
      loc=$(awk 'BEGIN{IGNORECASE=1} /^Location:/{sub(/^[^:]*:[[:space:]]*/,"",$0); print; exit}' "$hdrf" | tr -d '\r')
      [ -n "$loc" ] || { [ "$silent" = false ] && echo "curl-ossl: redirect without Location" >&2; rm -f "$hdrf" "$rawf"; return 22; }
      cur=$loc
      rm -f "$hdrf" "$rawf"
      continue
    fi

    te=$(awk 'BEGIN{IGNORECASE=1} /^Transfer-Encoding:/{print tolower($2)}' "$hdrf" | tr -d '\r')

    bodyf="$rawf"
    if [ "$te" = chunked ]
    then
      bodyf2=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-body")
      dechunk_file "$rawf" "$bodyf2"
      rm -f "$rawf"
      bodyf="$bodyf2"
    fi

    if [ -n "${outfile:-}" ]
    then
      cat "$bodyf" >"$outfile"
    else
      cat "$bodyf"
    fi

    rm -f "$hdrf" "$bodyf"

    if [ "$status" -ge 400 ] && $fail_on_error
    then
      return 22
    fi

    return 0
  done
}

# ---- run ----
follow "$url"
