#!/usr/bin/env sh
# curl-ossl: minimal curl-like wrapper using openssl s_client

set -eu

MAX_REDIRECTS_DEFAULT=5

usage() {
  cat <<EOF
Usage: $0 [OPTIONS] URL

Options:
  -s            Silent (no progress / errors from TLS)
  -o FILE       Write output body to FILE
  -I            Fetch headers only
  -L            Follow redirects
  -f            Fail on >=400 status
  -S            Show error (useful with -s)
  -h, --help    Show this help

Defaults:
  Follows up to $MAX_REDIRECTS_DEFAULT redirects.
EOF
}

silent=false
show_error=false
outfile=
head_only=false
fail_on_error=false
max_redirs=$MAX_REDIRECTS_DEFAULT
url=

# Parse args
while [ $# -gt 0 ]
do
  case "$1" in
    -s)
      silent=true
      ;;
    -S)
      show_error=true
      ;;
    -o)
      shift
      outfile=$1
      ;;
    -I)
      head_only=true
      ;;
    -L)
      max_redirs=$MAX_REDIRECTS_DEFAULT
      ;;
    -f)
      fail_on_error=true
      ;;
    -h|--help)
      usage
      return 0
      ;;
    -*)
      usage
      return 2
      ;;
    *)
      url=$1
      shift
      break
      ;;
  esac
  shift
done

[ -n "$url" ] || {
  usage
  return 2
}

# --- helpers ---

have_opt() {
  opt=$1
  openssl s_client -help 2>/dev/null | grep -q " $opt "
}

parse_url() {
  _u=$1
  case "$_u" in
    https://*)
      proto=https
      rest=${_u#https://}
      ;;
    http://*)
      proto=http
      rest=${_u#http://}
      ;;
    *)
      proto=https
      rest=$_u
      ;;
  esac
  case "$rest" in
    *"/"*)
      hostport=${rest%%/*}
      path=/${rest#*/} ;;
    *)
      hostport=$rest
      path=/ ;;
  esac
  case "$hostport" in
    *:*)
      host=${hostport%:*}
      port=${hostport#*:} ;;
    *)
      host=$hostport
      [ "$proto" = https ] && port=443 || port=80 ;;
  esac
  printf '%s %s %s %s\n' "$proto" "$host" "$port" "$path"
}

fetch_https_stream() {
  hdrf=$1
  rawf=$2
  _host=$3
  _port=$4
  _path=$5

  req="GET $_path HTTP/1.1\r\nHost: $_host\r\nUser-Agent: curl-ossl\r\nAccept: */*\r\nConnection: close\r\n\r\n"

  for args in \
    "-quiet -ign_eof -connect $_host:$_port -tls1_3 -servername $_host" \
    "-quiet -ign_eof -connect $_host:$_port -tls1_2 -servername $_host" \
    "-quiet -ign_eof -connect $_host:$_port -tls1_2"
  do
    errf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-err")

    printf '%b' "$req" \
    | openssl s_client $args 2>"$errf" \
    | {
        : >"$hdrf"
        while IFS= read -r line
        do
          line=$(printf '%s' "$line" | tr -d '\r')
          [ -z "$line" ] && break
          printf '%s\n' "$line" >>"$hdrf"
        done
        cat >"$rawf"
      } || true

    if head -n1 "$hdrf" | grep -q '^HTTP/'; then
      rm -f "$errf" || true
      return 0
    fi

    if [ "$silent" = false ] || [ "$show_error" = true ]
    then
      sed 's/^/openssl: /' "$errf" >&2 || true
    fi
    rm -f "$errf" || true
  done

  return 1
}

dechunk() {
  awk '
    function x2d(h,   n,i,c,v) {
      n=length(h); v=0
      for (i=1;i<=n;i++) {
        c=substr(h,i,1)
        v*=16
        if (c ~ /[0-9]/) v+=c
        else if (c ~ /[a-f]/) v+=ord(c)-ord("a")+10
        else if (c ~ /[A-F]/) v+=ord(c)-ord("A")+10
      }
      return v
    }
    function ord(str) { return index("abcdefghijklmnopqrstuvwxyz", tolower(str)) }
    {
      if (state==0) {
        sub(/\r$/,"")
        size=x2d($1)
        if (size==0) exit
        state=1; left=size
      } else {
        print
        left-=length($0)+1
        if (left<=0) state=0
      }
    }'
}

# --- main follow loop ---

follow() {
  cur=$1
  n=0
  while [ $n -le $max_redirs ]
  do
    n=$((n+1))
    set -- $(parse_url "$cur")
    proto=$1 host=$2 port=$3 path=$4

    hdrf=$(mktemp)
    rawf=$(mktemp)

    if [ "$proto" = https ]
    then
      fetch_https_stream "$hdrf" "$rawf" "$host" "$port" "$path" || return 1
    else
      echo "http not supported" >&2
      rm -f "$hdrf" "$rawf"
      return 1
    fi

    status=$(awk 'NR==1{print $2+0}' "$hdrf")

    if [ "$head_only" = true ]
    then
      cat "$hdrf"
      rm -f "$hdrf" "$rawf"
      return 0
    fi

    loc=$(awk 'BEGIN{IGNORECASE=1} /^Location:/{print $2}' "$hdrf" | tr -d '\r')
    te=$(awk 'BEGIN{IGNORECASE=1} /^Transfer-Encoding:/{print tolower($2)}' "$hdrf" | tr -d '\r')

    if [ -n "$loc" ] && [ $status -ge 300 ] && [ $status -lt 400 ]
    then
      cur=$loc
      rm -f "$hdrf" "$rawf"
      continue
    fi

    if [ $status -ge 400 ] && [ "$fail_on_error" = true ]
    then
      rm -f "$hdrf" "$rawf"
      return 22
    fi

    if [ "$te" = chunked ]
    then
      dechunk <"$rawf"
    else
      cat "$rawf"
    fi >"${outfile:-/dev/stdout}"

    rm -f "$hdrf" "$rawf"
    return 0
  done
  return 47
}

# --- invoke ---
follow "$url"
