#!/usr/bin/env sh
# curl-ossl â€” tiny curl-ish fetcher using openssl s_client (binary-safe)

set -eu

MAX_REDIRECTS_DEFAULT=5

usage() {
  echo "Usage: $0 [OPTIONS] URL"
  echo
  echo "Options:"
  echo "  -s                Silent (suppress TLS error chatter)"
  echo "  -S                Show errors (useful with -s)"
  echo "  -o FILE           Write body to FILE"
  echo "  -I                Headers only"
  echo "  -L                Follow redirects (default on)"
  echo "  --max-redirs N    Set redirect limit (default ${MAX_REDIRECTS_DEFAULT})"
  echo "  -f                Fail on HTTP >= 400 (exit 22)"
  echo "  -4                Force IPv4 (require A record; else exit 6)"
  echo "  -6                Force IPv6 (require AAAA; else exit 6)"
  echo "  -v, --verbose     Show debug output (DNS, openssl args, redirects)"
  echo "  -h, --help        Show this help"
}

silent=false
show_error=false
outfile=
head_only=false
fail_on_error=false
max_redirs=$MAX_REDIRECTS_DEFAULT
force_v4=false
force_v6=false
verbose=false
url=

# ---- args ----
while [ $# -gt 0 ]
do
  case "$1" in
    -s)
      silent=true
      shift
    ;;
    -S)
      show_error=true
      shift
    ;;
    -o)
      shift
      outfile=${1:-}
      [ -n "${outfile:-}" ] || { usage; exit 2; }
      shift
    ;;
    -I)
      head_only=true
      shift
    ;;
    -L)
      shift
    ;;
    --max-redirs)
      shift
      max_redirs=${1:-}
      [ -n "${max_redirs:-}" ] || { usage; exit 2; }
      shift
    ;;
    -f)
      fail_on_error=true
      shift
    ;;
    -4)
      force_v4=true
      force_v6=false
      shift
    ;;
    -6)
      force_v6=true
      force_v4=false
      shift
    ;;
    -v|--verbose)
      verbose=true
      shift
    ;;
    -h|--help)
      usage
      exit 0
    ;;
    -*)
      usage
      exit 2
    ;;
    *)
      url=$1
      shift
      break
    ;;
  esac
done

[ -n "${url:-}" ] || { usage; exit 2; }

case "$url" in
  http://*|https://*) : ;;
  *) url="https://$url" ;;
esac

parse_url() {
  _u=$1
  case "$_u" in
    https://*) proto=https; rest=${_u#https://} ;;
    http://*)  proto=http;  rest=${_u#http://}  ;;
    *)         proto=https; rest=$_u            ;;
  esac

  case "$rest" in
    */*) hostport=${rest%%/*}; path="/${rest#*/}" ;;
    *)   hostport=$rest;        path="/"          ;;
  esac

  case "$hostport" in
    *:*) host=${hostport%:*}; port=${hostport#*:} ;;
    *)   host=$hostport; [ "$proto" = https ] && port=443 || port=80 ;;
  esac

  printf '%s %s %s %s\n' "$proto" "$host" "$port" "$path"
}

resolve_ip_v4() {
  _host=$1
  ip=
  if command -v getent >/dev/null 2>&1
  then
    ip=$(getent ahostsv4 "$_host" 2>/dev/null | awk 'NF{print $1; exit}')
  fi
  if [ -z "${ip:-}" ] && command -v nslookup >/dev/null 2>&1
  then
    ip=$(nslookup -type=A "$_host" 2>/dev/null | awk '/^Address: /{print $2; exit}')
  fi
  [ -n "${ip:-}" ] || return 1
  printf '%s\n' "$ip"
}

resolve_ip_v6() {
  _host=$1
  ip6=

  # Prefer getent; ignore IPv4-mapped (::ffff:a.b.c.d) and v4-in-v6 forms
  if command -v getent >/dev/null 2>&1
  then
    ip6=$(getent ahostsv6 "$_host" 2>/dev/null | awk '
      {
        ip=$1
        # reject IPv4-mapped (::ffff:a.b.c.d) and ::a.b.c.d style
        if (ip ~ /^::ffff:/) next
        if (ip ~ /::[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$/) next
        # accept the first real IPv6 address
        if (index(ip, ":") > 0) { print ip; exit }
      }')
  fi

  # Fallback to nslookup AAAA (never returns mapped v6)
  if [ -z "${ip6:-}" ] && command -v nslookup >/dev/null 2>&1
  then
    ip6=$(nslookup -type=AAAA "$_host" 2>/dev/null \
          | awk '/has IPv6 address/ { print $NF; exit }')
  fi

  [ -n "${ip6:-}" ] || return 1
  printf '%s\n' "$ip6"
}


bracket_if_ipv6() {
  case "$1" in
    *:*) printf '[%s]\n' "$1" ;;
    *)   printf '%s\n' "$1"   ;;
  esac
}

fetch_https_stream() {
  hdrf=$1
  rawf=$2
  _host=$3
  _port=$4
  _path=$5

  connect_host=
  if $force_v4
  then
    connect_host=$(resolve_ip_v4 "$_host") || {
      $verbose && echo ">>> no A record for $_host" >&2
      return 6
    }
    $verbose && echo ">>> resolved IPv4: $connect_host" >&2
  elif $force_v6
  then
    connect_host=$(resolve_ip_v6 "$_host") || {
      $verbose && echo ">>> no AAAA record for $_host" >&2
      return 6
    }
    $verbose && echo ">>> resolved IPv6: $connect_host" >&2
  else
    connect_host="$_host"
    $verbose && echo ">>> using host as-is: $connect_host" >&2
  fi

  connect_target="$(bracket_if_ipv6 "$connect_host"):${_port}"
  req="GET $_path HTTP/1.1\r\nHost: $_host\r\nUser-Agent: curl-ossl\r\nAccept: */*\r\nConnection: close\r\n\r\n"

  for args in \
    "-quiet -ign_eof -connect $connect_target -tls1_3 -servername $_host" \
    "-quiet -ign_eof -connect $connect_target -tls1_2 -servername $_host" \
    "-quiet -ign_eof -connect $connect_target -tls1_2"
  do
    $verbose && echo ">>> openssl s_client $args" >&2
    errf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-err")

    printf '%b' "$req" \
    | openssl s_client $args 2>"$errf" \
    | {
        : >"$hdrf"
        while IFS= read -r line
        do
          line=$(printf '%s' "$line" | tr -d '\r')
          [ -z "$line" ] && break
          printf '%s\n' "$line" >>"$hdrf"
        done
        cat >"$rawf"
      } || true

    if head -n1 "$hdrf" | grep -q '^HTTP/'; then
      $verbose && echo ">>> got HTTP response" >&2
      rm -f "$errf"
      return 0
    fi

    if [ "$silent" = false ] || [ "$show_error" = true ] || $verbose
    then
      sed 's/^/openssl: /' "$errf" >&2 || true
    fi
    rm -f "$errf"
  done

  return 1
}

dechunk_file() {
  in=$1
  out=$2
  : >"$out"
  exec 9<"$in"

  while IFS= read -r -u 9 line
  do
    line=$(printf '%s' "$line" | tr -d '\r')
    sizehex=${line%%;*}
    [ -n "$sizehex" ] || continue
    case "$sizehex" in *[!0-9a-fA-F]* ) break ;; esac
    size=$((16#$(printf '%s' "$sizehex" | tr 'a-f' 'A-F')))
    [ "$size" -gt 0 ] || break
    dd bs=1 count="$size" <&9 >>"$out" 2>/dev/null || true
    IFS= read -r -u 9 _ || true
  done

  exec 9<&-
}

follow() {
  cur=$1
  n=0

  while :; do
    n=$((n+1))
    [ "$n" -le "$max_redirs" ] || { echo "curl-ossl: too many redirects" >&2; return 22; }

    set -- $(parse_url "$cur")
    proto=$1; host=$2; port=$3; path=$4
    $verbose && echo ">>> request: $proto://$host:$port$path" >&2

    hdrf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-hdr")
    rawf=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-raw")

    if ! fetch_https_stream "$hdrf" "$rawf" "$host" "$port" "$path"
    then
      rc=$?
      rm -f "$hdrf" "$rawf"
      return "$rc"
    fi

    status=$(head -n1 "$hdrf" | awk '{print $2+0}')
    [ -z "$status" ] && status=0
    $verbose && echo ">>> HTTP status: $status" >&2

    if [ "$head_only" = true ]
    then
      cat "$hdrf"
      rm -f "$hdrf" "$rawf"
      return "$status"
    fi

    if [ "$status" -ge 300 ] && [ "$status" -lt 400 ]
    then
      loc=$(awk 'BEGIN{IGNORECASE=1} /^Location:/{sub(/^[^:]*:[[:space:]]*/,"",$0); print; exit}' "$hdrf" | tr -d '\r')
      $verbose && echo ">>> redirect to $loc" >&2
      cur=$loc
      rm -f "$hdrf" "$rawf"
      continue
    fi

    te=$(awk 'BEGIN{IGNORECASE=1} /^Transfer-Encoding:/{print tolower($2)}' "$hdrf" | tr -d '\r')
    bodyf="$rawf"
    if [ "$te" = chunked ]
    then
      bodyf2=$(mktemp 2>/dev/null || echo "/tmp/curl-ossl.$$-body")
      dechunk_file "$rawf" "$bodyf2"
      rm -f "$rawf"
      bodyf="$bodyf2"
    fi

    if [ -n "${outfile:-}" ]
    then
      cat "$bodyf" >"$outfile"
    else
      cat "$bodyf"
    fi

    rm -f "$hdrf" "$bodyf"

    if [ "$status" -ge 400 ] && $fail_on_error
    then
      return 22
    fi

    return 0
  done
}

# ---- run ----
follow "$url"
